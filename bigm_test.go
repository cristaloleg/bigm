package bigm

import (
	"fmt"
	"testing"
)

func Test_modInverse(t *testing.T) {
	tests := []struct {
		a    int32
		m    int32
		want int32
	}{
		{3, 11, 4},
	}
	for i, tt := range tests {
		t.Run(fmt.Sprintf("test %d", i), func(t *testing.T) {
			if got := modInverse(tt.a, tt.m); got != tt.want {
				t.Errorf("modInverse() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestAdd(t *testing.T) {
	tests := []struct {
		x    string
		y    string
		want string
	}{
		{"34", "44", "78"},
		{"123", "321", "444"},
		{"123123123", "321321321", "444444444"},
		{
			"321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321",
			"123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123",
			"444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444",
		},
		{
			"321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321",
			"123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123",
			"444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444",
		},
	}
	for i, tt := range tests {
		t.Run(fmt.Sprintf("test %d", i), func(t *testing.T) {
			xx := FromString(tt.x)
			yy := FromString(tt.y)
			if got := Add(xx, yy).String(); tt.want != got {
				t.Errorf("Add() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestSub(t *testing.T) {
	tests := []struct {
		x    string
		y    string
		want string
	}{
		{"44", "34", "10"},
		{"321", "123", "198"},
		{"321321321", "123123123", "198198198"},
		{
			"444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444",
			"321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321",
			"123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123",
		},
	}
	for i, tt := range tests {
		t.Run(fmt.Sprintf("test %d", i), func(t *testing.T) {
			xx := FromString(tt.x)
			yy := FromString(tt.y)
			if got := Sub(xx, yy).String(); tt.want != got {
				t.Errorf("Sub() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMul(t *testing.T) {
	tests := []struct {
		x    string
		y    string
		want string
	}{
		{"44", "34", "1496"},
		{"321", "123", "39483"},
		{
			"321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321",
			"123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123123321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321321",
			"39562084607129652174697219742264787309832354877399922444967490012535057580102625147670192715237760282805327850372959103247391535679823968112256400544688832977121265409553697841986130274418562706850995139283427571715860004148292372895417940462985508030553075598120643165688210733255778300823345868390913435958481003526048571093616138661183706292436580724869013157301445589733878022166310454598742887031175319463607751896040184328472616760905049193337481625627104582059537014491969446924401879356834311789266744221699176654131609086564041518996473951428906383861338816293707563419275130986842698554410266121977833689545401257112968824680536392248103959815671527383239094950806662518374293771248726203681158636113591068546023500978455933410888365843320798275753230708185663140618095573050528005482960374230085941797653509365221076932788644500356212067923779635491347203058914770626482338194049905761617473329185041",
		},
	}
	for i, tt := range tests {
		t.Run(fmt.Sprintf("test %d", i), func(t *testing.T) {
			xx := FromString(tt.x)
			yy := FromString(tt.y)
			if got := Mul(xx, yy).String(); tt.want != got {
				t.Errorf("Mul() = %v, want %v", got, tt.want)
			}
		})
	}
}
func TestModInv(t *testing.T) {
	tests := []struct {
		x    string
		y    string
		want string
	}{
		{"44", "34", ""},
		{"321", "123", ""},
		{"3", "11", "4"},
		{"3", "14", "5"},
	}
	for i, tt := range tests {
		t.Run(fmt.Sprintf("test %d", i), func(t *testing.T) {
			xx := FromString(tt.x)
			yy := FromString(tt.y)
			if got := ModInv(xx, yy).String(); tt.want != got {
				t.Errorf("ModInv() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestIsCoprime(t *testing.T) {
	tests := []struct {
		x    string
		y    string
		want bool
	}{
		{"44", "34", false},
		{"321", "123", false},
		{"3", "11", true},
		{"3", "14", true},
	}
	for i, tt := range tests {
		t.Run(fmt.Sprintf("test %d", i), func(t *testing.T) {
			xx := FromString(tt.x)
			yy := FromString(tt.y)
			if got := IsCoprime(xx, yy); tt.want != got {
				t.Errorf("IsCoprime() = %v, want %v", got, tt.want)
			}
		})
	}
}
